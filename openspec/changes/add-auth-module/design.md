## 背景

认证模块是保护用户数据和提供个性化体验的关键组件。该模块将处理用户注册、登录、会话管理以及应用重启后的自动认证。

**约束条件：**
- 必须与现有的 Taro 小程序框架集成
- 必须使用提供的后端 API 端点
- 必须支持基于 token 的认证和 SID
- 必须在小程序环境中安全处理 token 存储
- 必须为认证页面提供美观的 UI

**利益相关者：**
- 最终用户：需要安全、易用的登录/注册体验
- 后端团队：提供基于 token/SID 机制的认证 API
- 开发团队：需要可维护、结构良好的代码

## 目标 / 非目标

**目标：**
- 实现完整的认证流程（注册 → 登录 → 已认证会话）
- 提供安全的 token 存储和自动 token 刷新
- 确保所有 API 请求在请求头中包含有效的 SID
- 为认证页面创建现代、响应式的 UI
- 处理边界情况（网络错误、token 过期、无效凭据）
- 支持应用启动时的自动登录

**非目标：**
- 社交登录（OAuth、微信登录）- 超出此变更范围
- 密码重置功能 - 可以后续添加
- 双因素认证 - 可以后续添加
- 生物识别认证 - 可以后续添加
- 用户资料管理 - 独立功能

## 技术决策

### 决策 1：状态管理方案

**选择：** 使用 Taro 内置的 `useRouter` 和 React hooks 管理本地状态 + 使用简单的 Taro storage 进行持久化

**理由：**
- 对于认证状态（用户登录/登出、token、SID）轻量级
- 避免了 Redux/Vuex 的复杂性，仅用于简单的布尔值/token 状态
- Taro.setStorageSync/getStorageSync 足以应对 token 持久化
- 易于实现和维护

**考虑的替代方案：**
- Redux：对于单个布尔值 + token 状态过于复杂
- MobX：对于此用例，额外依赖不合适
- Context API：有效的替代方案，但 router + storage 更简单

### 决策 2：API 客户端架构

**选择：** 使用 Taro.request 创建集中的请求包装器（`src/utils/request.ts`），配合拦截器

**理由：**
- 单一位置实现 SID 注入逻辑
- 所有 API 调用的一致错误处理
- 易于在开发中添加请求/响应日志
- 遵循 Taro 最佳实践
- Token 刷新逻辑可以在一个地方添加

**实现：**
```typescript
// 请求拦截器添加 SID 请求头
config.header = {
  ...config.header,
  'sid': getStoredSid()
}

// 响应拦截器处理 401 错误
if (statusCode === 401) {
  clearTokens()
  navigateToLogin()
}
```

### 决策 3：Token 存储策略

**选择：** 使用 Taro.setStorageSync 存储 token 和 SID

**理由：**
- 跨应用重启持久化
- 在小程序沙箱中安全（无法访问其他应用）
- 简单的同步 API
- 无需异步存储的复杂性

**存储键：**
- `auth_token`：用于自动登录的 JWT token
- `auth_sid`：用于 API 请求的当前会话 ID
- `auth_expires`：Token 过期时间戳

### 决策 4：认证流程架构

**选择：** 在 `app.ts` 中实现启动检查，配合路由守卫逻辑

**理由：**
- 认证检查的单一入口点
- 防止对受保护页面的未认证访问
- 公共页面（登录/注册）和私有页面（主页）的清晰分离

**流程：**
```
应用启动
  ↓
检查存储的 token？
  ├─ 否 → 显示登录页面
  └─ 是 → 调用自动登录 API
            ├─ 成功 → 导航到主页
            └─ 失败 → 显示登录页面
```

### 决策 5：表单验证策略

**选择：** API 调用前的客户端验证 + 服务端错误显示

**理由：**
- 为常见错误（空字段、密码不匹配）提供即时反馈
- 减少不必要的 API 调用
- 为验证失败显示服务端错误（用户名存在、凭据无效）

**验证规则：**
- 用户名：3-20 个字符，字母数字
- 密码：最少 8 个字符，必须包含字母和数字
- 确认密码：必须与密码匹配

### 决策 6：UI/UX 设计方案

**选择：** 现代、居中的卡片设计，配合渐变背景

**理由：**
- 适合音乐应用的专业外观
- 表单清晰的视觉层次
- 跨设备的响应式设计
- 遵循当前设计趋势

**设计元素：**
- 全屏渐变背景
- 带阴影的居中白色卡片
- 带图标的大型可读输入框
- 突出的行动号召按钮
- 登录/注册之间的平滑过渡

## 风险 / 权衡

### 风险 1：Token 存储安全性

**风险：** 如果设备被泄露，存储在 Taro storage 中的 token 可能被访问

**缓解措施：**
- 所有 API 调用使用 HTTPS
- Token 有过期时间
- 实现登出以清除 token
- 考虑在未来添加 token 加密

### 风险 2：网络可靠性

**风险：** API 调用可能因网络问题而失败

**缓解措施：**
- 实现超时处理（10 秒）
- 显示用户友好的错误消息
- 为自动登录添加重试逻辑
- 如需要，提供离线指示器

### 风险 3：Token 过期处理

**风险：** 如果 token 过期，用户可能意外被登出

**缓解措施：**
- 在应用启动时检查 token 过期时间
- 如果 API 支持，实现自动刷新
- 清除过期的 token 并重定向到登录
- 显示清晰的消息说明登出原因

### 权衡 1：单一页面 vs 分离页面

**决策：** 分离的登录和注册页面

**权衡：**
- 优点：更清晰的 URL 路由，更简单的组件
- 缺点：需要页面之间的导航
- 正当性：为首次用户提供更好的 UX，更易于维护

### 权衡 2：表单验证复杂性

**决策：** 基本客户端验证 + 服务端验证

**权衡：**
- 优点：快速的用户反馈，减少服务器负载
- 缺点：重复的验证逻辑
- 正当性：更好的 UX 证明了少量的代码重复是合理的

## 迁移计划

由于这是一个新功能，现有代码无需迁移。但是：

### 阶段 1：核心认证（1-2 天）
1. 创建认证服务层
2. 实现请求拦截器
3. 添加 token 存储工具
4. 测试 API 集成

### 阶段 2：UI 实现（2-3 天）
1. 构建登录页面
2. 构建注册页面
3. 添加表单验证
4. 样式化组件

### 阶段 3：集成（1 天）
1. 在 app.ts 中添加启动检查
2. 将认证流程连接到导航
3. 测试完整的用户旅程

### 回滚计划
- 通过从 app.ts 中移除启动检查来禁用功能
- 所有变更都隔离在认证模块中（对现有代码无破坏性变更）
- 如果发现关键问题，可以恢复提交

## 开放问题

1. **Token 刷新机制：** 后端 API 是否支持 token 刷新，还是用户必须在过期后重新登录？
   - **假设：** 根据提供的 API 文档，自动登录端点处理 token 刷新

2. **会话超时：** 预期的 SID 过期时间是多少？
   - **假设：** 后端处理过期，客户端响应 401 错误

3. **密码要求：** 除了文档中提到的内容，是否有特定的密码复杂性规则？
   - **假设：** 最少 8 个字符，字母和数字（基于示例）

4. **用户名限制：** 是否有保留的用户名或格式限制？
   - **假设：** 3-20 个字母数字字符（标准实践）

5. **多设备支持：** 同一用户可以同时在多个设备上登录吗？
   - **假设：** 可以，基于基于 token 的架构

## 架构图

```
┌─────────────────────────────────────────────────────┐
│                    应用层                           │
│  ┌──────────────┐         ┌──────────────────────┐ │
│  │ 登录页面     │         │ 注册页面             │ │
│  └──────┬───────┘         └──────────┬───────────┘ │
│         │                             │             │
│         └──────────┬──────────────────┘             │
│                    ↓                                │
│         ┌──────────────────────┐                   │
│         │  认证服务层          │                   │
│         │  - login()           │                   │
│         │  - register()        │                   │
│         │  - autoLogin()       │                   │
│         └──────────┬───────────┘                   │
└────────────────────┼───────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│                  存储层                             │
│  ┌──────────────────────────────────────────────┐  │
│  │ Taro.setStorageSync                           │  │
│  │ - auth_token                                  │  │
│  │ - auth_sid                                    │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│              请求拦截器层                           │
│  ┌──────────────────────────────────────────────┐  │
│  │ - 将 SID 注入到请求头中                       │  │
│  │ - 处理 401 响应                               │  │
│  │ - 处理网络错误                                │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│                   后端 API                          │
│  POST /auth/register                                │
│  POST /api/login                                    │
│  POST /auth/auto-login                              │
└─────────────────────────────────────────────────────┘
```

## 数据流

### 注册流程
```
用户输入凭据
  ↓
客户端验证输入
  ↓
调用 POST /auth/register
  ↓
后端创建用户
  ↓
存储 user_id（如果需要）
  ↓
导航到登录页面
```

### 登录流程
```
用户输入凭据
  ↓
客户端验证输入
  ↓
调用 POST /api/login
  ↓
后端验证凭据
  ↓
存储 token + SID
  ↓
导航到主页
```

### 自动登录流程
```
应用启动
  ↓
检查存储的 token
  ↓
使用 token 调用 POST /auth/auto-login
  ↓
后端验证 token
  ↓
存储新的 SID
  ↓
导航到主页
```

### API 请求流程
```
组件调用 API
  ↓
请求拦截器注入 SID
  ↓
发送带有 SID 请求头的请求
  ↓
后端验证 SID
  ↓
返回响应或 401 错误
  ↓
响应拦截器处理结果
```

## 安全考虑

1. **Token 存储：** 使用 Taro 的安全存储（沙箱化）
2. **仅 HTTPS：** 所有 API 调用通过 HTTPS 进行
3. **SID 注入：** 永远不要在错误消息中记录或暴露 SID
4. **密码处理：** 永远不要存储密码，只存储 token
5. **错误消息：** 通用消息以防止用户名枚举
6. **会话管理：** 登出时清除 token
7. **输入验证：** 在 API 调用前清理所有用户输入
